<!DOCTYPE html>
<html>
<head>
<title>Canvas</title>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<style>
body{  
	margin:0;
    padding:5px;
    border:0;
    font-family:georgia,verdana,sans-serif;
    font-size:14px;	
    background-color:#CCCCCC;
}
#thecanvas{
     background-color:#ffffff;
}
#txtAddCount{
    width:50px;
}
</style>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script type="text/javascript">
var TSP = (function(){

    var CIRCLE_RADIUS = 4.0;
    var LINE_COLOR = 'rgb(0,0,255)';  
    var LINE_WIDTH = 1.0;  
    var DONE = 'Done.';
    
    function rand(u){      
        return Math.floor(Math.random() * (u + 1));
    }
    
    //skip the sqrt for comparison versus absolute distance
    function relativeDist(pt1, pt2){
        var xDelta = pt1.x - pt2.x;
        var yDelta = pt1.y - pt2.y;
        return (xDelta * xDelta) + (yDelta * yDelta);
    }
    
    function distance(pt1, pt2){
        return Math.sqrt(relativeDist(pt1, pt2));
    }
    
    function arrayCopy(arr){
        var result = [];
        var l = arr.length;
        for(var i =0; i < l; i++)
            result.push(arr[i]);
        return result;
    }
    
    function swap(arr, swapx, swapy){
        var temp = arr[swapx];
        arr[swapx] = arr[swapy];
        arr[swapy] = temp;
    }
    
    function sortDistance(a,b){
        return a.distance - b.distance;
    }
    
    var point = function(x,y){
        this.x = x;
        this.y = y;       
    };
    
    var model = function(){
        this.points = [];
    };
    model.prototype = {
        getPossible: function(){
            var possible = [];
            var pl = this.points.length;
            for(var i = 0; i < pl; i++)
                possible.push(i);
            return possible;
        },
        partialDistance: function(indexes){
            var pts = this.points;
            var d = 0.0;
            for(var i=1;i<indexes.length;i++)             
                d += distance(pts[indexes[i]], pts[indexes[i - 1]]);
            return d;
        },
        pathDistance: function(indexes){
            var pts = this.points;
            var d = this.partialDistance(indexes);           
            d += distance(pts[indexes[indexes.length - 1]], pts[indexes[0]]);  
            return d;
        }, 
        randomPath: function(){
            var indexes = [];
            var possible = this.getPossible();                
            while(possible.length > 0){
                var index = rand(possible.length - 1);
                indexes.push(possible[index]);
                possible.splice(index, 1);
            }                
           
            return indexes;
        },
        getNNFromStartingPoint: function(current){
            var indexes = [];          
            var possible = this.getPossible();
            
            indexes.push(current);
            possible.splice(current, 1);
            
            var next = -1;
            while(possible.length > 0){
                var max = Number.MAX_VALUE;
                for(var i = 0; i < possible.length; i++){ 
                    var dist = relativeDist(this.points[current], this.points[possible[i]]);
                    if(dist < max){
                        max = dist;
                        next = i;
                    }                       
                }
                current = possible[next];
                indexes.push(current);  
                possible.splice(next, 1);                    
            }
            return indexes;
        },
        getBestPath: function(indexes){                  
            var inner = indexes.slice(1,-1);           
            var solutions = [];
            this.getBestPathRecurse(inner, [], solutions);
            
            var limit = solutions.length;            
            var best = Number.MAX_VALUE;
            var result = null;
            for(var i = 0; i < limit; i++){
                for(var j = 0; j < solutions[i].length; j++){
                    indexes[j + 1] = solutions[i][j];
                }
                var d = this.partialDistance(indexes);
                if(d < best){
                    best = d;
                    result = arrayCopy(indexes);
                }
            }
            return result;
        },
        getBestPathRecurse: function(possible, solution, result){
            var pl = possible.length;
            if(pl == 0){
                result.push(arrayCopy(solution));
                return;
            }            
            for(var i = 0; i < pl; i++){
                solution.push(possible.splice(i, 1)[0]);
                this.getBestPathRecurse(possible, solution, result);
                possible.splice(i, 0, solution.pop());
            }
        }
    };
    
    var controller = function(canvas, log, logIter, logImprove){
    
        this.model = new model();
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.log = log; 
        this.logIter = logIter;
        this.logImprove = logImprove;
        this.timeout = 0;
        
        var ctrl = this;
        $(this.canvas).mousedown(function(e){   
            ctrl.reset();
            var x = e.clientX - this.offsetLeft + (window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft);
            var y = e.clientY - this.offsetTop + (window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop);
            ctrl.model.points.push(new point(x,y));          
            ctrl.draw();
        });
    };
    
    controller.prototype = {  
        solve: function(solverName){
            this.reset();           
            var solver = new this[solverName](this);            
            solver.iteration = 0;
            solver.improvements = 0;
            solver.best = Number.MAX_VALUE;
            solver.solve();           
        },               
        reset: function(){
            this.stop();
            this.clearLogs();          
        },
        stop: function(){                      
            clearTimeout(this.timeout);           
        },
        clear: function(){
            this.stop();
            this.model = new model();
            this.draw();
            this.clearLogs();
        },  
        clearLogs: function(){
            this.log('');
            this.logIter('');
            this.logImprove('');
        },
        addRandom: function(c){          
            var count = parseInt(c);
            if(!isNaN(count)) { 
                var pts = this.model.points;
                for(var i=0;i<count;i++){
                    pts.push(new point(rand(this.canvas.width),rand(this.canvas.height)));                    
                }
                this.draw();             
            }
        },          
        draw: function(indexes){        
            var ctx = this.ctx;
            var model = this.model;
            var pts = model.points;
            ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
            for(var i=0;i<pts.length;i++){
                ctx.beginPath();
                ctx.arc(pts[i].x,pts[i].y,CIRCLE_RADIUS,0,Math.PI*2,true);
                ctx.fill();
            }  
            if(indexes && indexes.length > 1){
                ctx.save();
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = LINE_WIDTH;              
                ctx.moveTo(pts[indexes[0]].x, pts[indexes[0]].y);
                for(var i=1;i<indexes.length;i++)
                      ctx.lineTo(pts[indexes[i]].x, pts[indexes[i]].y);
                ctx.lineTo(pts[indexes[0]].x, pts[indexes[0]].y);    
                ctx.stroke(); 
                ctx.restore();
                
                var d = model.pathDistance(indexes);
                this.log(d);
            }
        }        
    };
    
    controller.prototype.bruteforce = function(ctrl){
    
        var model = ctrl.model;
        var pts = model.points;
        this.possible = ctrl.model.getPossible();
        this.solution = [];
        this.depth = 0;
        this.indexStack = []; 
        this.distanceStack = [];
        for(var i = 0; i < this.possible.length; i++){
            this.indexStack.push(0);
            this.distanceStack.push(0.0);        
        }
        this.runningDistance = 0.0;        
        this.solution.push(this.possible.pop()); 
           
        this.solve = function(){ 
          
            var iStack = this.indexStack;     
            var dStack = this.distanceStack;           
            var solution = this.solution;
            var possible = this.possible;
            
            var loop = 0;
          
            while(loop++ < 250){
                if(possible.length == 1){ //arrived at a leaf              
                    var d = distance(pts[solution[solution.length-1]], pts[possible[0]])
                        + distance(pts[possible[0]], pts[solution[0]]);
                    if(d + this.runningDistance < this.best){
                        this.best = d + this.runningDistance;
                        solution.push(possible.pop());
                        ctrl.draw(solution);
                        possible.push(solution.pop());
                        ctrl.logImprove(++this.improvements);
                    }        
                    this.depth--;
                    if(this.depth < 0){
                        ctrl.logIter(DONE); 
                        return;   
                    }
                    possible.splice(iStack[this.depth],0,solution.pop());
                    iStack[this.depth]++;  
                    this.runningDistance -= dStack[this.depth];
                    ctrl.logIter(this.iteration++);                
                }        
                else if(iStack[this.depth] >= possible.length){ //out of options at this depth               
                    this.depth--;
                    if(this.depth < 0){
                        ctrl.logIter(DONE); 
                        return;   
                    }
                    possible.splice(iStack[this.depth],0,solution.pop());
                    iStack[this.depth]++;
                    this.runningDistance -= dStack[this.depth];
                }
                else{ //regular node                          
                    var d = distance(pts[possible[iStack[this.depth]]], pts[solution[solution.length-1]]);
                    this.runningDistance += d;
                    if(this.runningDistance >= this.best){                   
                        iStack[this.depth]++;                  
                        this.runningDistance -= d;
                        ctrl.logIter(this.iteration++);  
                    }
                    else{
                        solution.push(possible.splice(iStack[this.depth],1)[0]);
                        dStack[this.depth] = d;
                        iStack[this.depth+1] = 0;
                        dStack[this.depth+1] = 0.0;
                        this.depth++;
                    }
                }  
            }            
            
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
    };

    controller.prototype.random = function(ctrl){ 
        var model = ctrl.model;
        this.solve = function(){           
            var rp = model.randomPath();
            var d = model.pathDistance(rp);
            ctrl.logIter(this.iteration++);
            if(d < this.best){
                this.best = d;
                ctrl.draw(rp);
                ctrl.logImprove(this.improvements++);
            }
        };
    };
    
    controller.prototype.iteraterandom = function(ctrl){ 
        var model = ctrl.model;
        this.solve = function(){           
            var rp = model.randomPath();
            var d = model.pathDistance(rp);
            ctrl.logIter(this.iteration++);
            if(d < this.best){
                this.best = d;
                ctrl.draw(rp);
                ctrl.logImprove(this.improvements++);
            }
            var self = this;  
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
    };
    
    controller.prototype.bestnn = function(ctrl){       
        this.bestPath = [];       
        this.index = 0;
        this.model = ctrl.model;
        this.points = this.model.points;
        this.solve = function(){           
            ctrl.logIter(this.iteration++);
            if(this.index >= this.points.length)
                return;
            var next = this.model.getNNFromStartingPoint(this.index++);
            var d = this.model.pathDistance(next);
            if(d < this.best){
                this.bestPath = next;
                this.best = d;
                ctrl.draw(this.bestPath);
                ctrl.logImprove(++this.improvements);
            }
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
    };
    
    controller.prototype.swapimprove = function(ctrl){    
        var model = ctrl.model;
        this.solve = function(){          
            this.bestPath = model.randomPath();
            this.best = model.pathDistance(this.bestPath);
            this.swapx = 0;
            this.swapy = 1;
            this.found = false;
            ctrl.draw(this.bestPath);
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.step(); }, 0); 
        };
        this.step = function(){
            ctrl.logIter(this.iteration++);
            var candidate = arrayCopy(this.bestPath);
            swap(candidate, this.swapx, this.swapy);          
            var d = model.pathDistance(candidate);
            if(d < this.best){
                this.bestPath = candidate;
                this.best = d;              
                ctrl.logImprove(++this.improvements);
                ctrl.draw(this.bestPath);
                this.found = true;
            }
            else
            {
                this.swapy++;
                if(this.swapy >= this.bestPath.length){
                    this.swapx++;
                    this.swapy = this.swapx + 1;
                }
                if(this.swapx >= this.bestPath.length - 1){
                    if(this.found){
                        this.swapx = 0;
                        this.swapy = 1;
                        this.found = false;
                    }
                    else{
                        ctrl.logIter(DONE);
                        return;
                    }
                }
            }
            
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.step(); }, 0); 
        };
    };
    
    var mutate = function(gene, count){
        var mutations = count || 1;
        for(var i = 0; i < mutations; i++){
            var first = rand(gene.length - 1);
            var second = rand(gene.length - 1);
            while(first == second) 
                second = rand(gene.length - 1);
            swap(gene, first, second);             
        }
    };
    
    var population = function(model){
        this.genes = [];
        this.model = model;      
    };
    population.prototype = {
        addRandomGenes: function(count){
            for(var i = 0; i < count; i++)
                this.genes.push(this.model.randomPath());
        },
        push: function(item){
            this.genes.push(item);
        },
        getSortedPopulation: function(){ 
            var pop = this.genes;
            var pl = pop.length;
            var sorted = [];
            for(var i = 0; i < pl; i++){
                pop[i].distance = this.model.pathDistance(pop[i]);
                sorted.push(pop[i]);
            } 

            sorted.sort(sortDistance);
            return sorted;
        },       
        crossover: function(sorted){ 
        
            var selected = [0,1,2,3,4,10,25,55,95];
            var population = this.genes;
            population.length = 0;
            for(var i = 0; i < selected.length; i++){
                population.push(sorted[selected[i]]);
            }
            //add randomness
            population.push(this.model.randomPath());
            
            var length = population[0].length;
            
            for(var i = 0; i < 10; i++){
                var mother = population[i];
                for(var j = 0; j < 10; j++){                   
                    if(i != j){
                        var father = arrayCopy(population[j]);
                        var child = [];   
                        var begin = rand(length - 1);
                        var end = 0;
                        var afterend = 0;
                        do{
                            end = rand(length - 1);
                            afterend = end + 1;
                            if(afterend == length) afterend = 0;    
                        }
                        while(end == begin || afterend == begin);
                        
                        var cursor = begin;                       
                        while(cursor != afterend){                           
                            child[cursor] = mother[cursor];
                            var fi = 0;
                            while(mother[cursor] != father[fi])
                                fi++;
                            father.splice(fi, 1);
                            cursor++;
                            if(cursor == length) cursor = 0;
                        } 
                        
                        while(cursor != begin){
                            child[cursor] = father.pop();
                            cursor++;
                            if(cursor == length) cursor = 0;
                        } 
                        
                        population.push(child);
                    }
                }
            }           
        }        
    };
    
    controller.prototype.gamutation = function(ctrl){
      
        this.population = new population(ctrl.model);
        this.population.addRandomGenes(100);
        this.solve = function(){
            ctrl.logIter(this.iteration++);
            var selected = [0,1,2,3,4,10,25,55,95];         
            var sorted = this.population.getSortedPopulation();
            if(sorted[0].distance < this.best){             
                this.best = sorted[0].distance;
                ctrl.logImprove(++this.improvements);
                ctrl.draw(sorted[0]);
            }
            this.population = new population(ctrl.model);
            for(var i = 0; i < 9; i++){
                var winner = sorted[selected[i]];
                this.population.push(winner);
                for(var j = 0; j < 9; j++){
                    var child = arrayCopy(winner);
                    mutate(child, rand(5));
                    this.population.push(child);
                }
            } 
            //throw in some randomness
            this.population.addRandomGenes(10);
          
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };       
    };
    
    controller.prototype.gacrossover = function(ctrl){
    
        this.population = new population(ctrl.model);
        this.population.addRandomGenes(100);
            
        this.solve = function(){
            ctrl.logIter(this.iteration++);
            var sorted = this.population.getSortedPopulation();
            if(sorted[0].distance < this.best){             
                this.best = sorted[0].distance;
                ctrl.logImprove(++this.improvements);
                ctrl.draw(sorted[0]);
            }
            this.population.crossover(sorted);
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
    };
    
    controller.prototype.ga = function(ctrl){
        
        this.population = new population(ctrl.model);
        this.population.addRandomGenes(100);
            
        this.solve = function(){
            ctrl.logIter(this.iteration++);
            var sorted = this.population.getSortedPopulation();
            if(sorted[0].distance < this.best){             
                this.best = sorted[0].distance;
                ctrl.logImprove(++this.improvements);
                ctrl.draw(sorted[0]);
            }
            this.population.crossover(sorted);
            var pl = this.population.genes.length;
            for(var i = 5; i < pl; i++)
                mutate(this.population.genes[i], rand(1));                        
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
    };
    
    controller.prototype.localpathimprove = function(ctrl){
    
        var model = ctrl.model;
        this.path = model.randomPath();
        this.best = model.pathDistance(this.path);
        this.start = 0;
        this.end = 8;
        var pl = this.path.length;
        ctrl.draw(this.path);
        this.count = 0;
        
        this.solve = function(){
           
            ctrl.logIter(this.iteration++);
            this.count++;
            var sample = [];
            for(var i = this.start; i < this.end; i++)
                sample.push(this.path[i % pl]);
                
            var result = model.getBestPath(sample);
            for(var i = this.start, y = 0; i < this.end; i++, y++)
                this.path[i % pl] = result[y];
            var distance = model.pathDistance(this.path);
            if(distance < this.best){
                this.best = distance;
                ctrl.logImprove(++this.improvements);
                ctrl.draw(this.path);
                this.count = 0;
            }
            this.start++;
            this.end++;
           
            if(this.count > pl * 2){
                ctrl.logIter(DONE);
                return;
            }
            
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);          
        };
    };

    controller.prototype.bestnnthenga = function(ctrl){

        this.bestPath = [];       
        this.index = 0;
        this.model = ctrl.model;
        this.points = this.model.points;

        this.population = new population(ctrl.model);
        this.population.addRandomGenes(100);
        this.population[0] = arrayCopy(ctrl.model.points);

        this.solve = function(){     
            var self = this;
            ctrl.logIter(this.iteration++);
            if(this.index >= this.points.length) {
                ctrl.timeout = setTimeout(function() { self.gasolve(); }, 0);
                return;
            }

            var next = this.model.getNNFromStartingPoint(this.index++);
            var d = this.model.pathDistance(next);
            if(d < this.best){
                this.bestPath = next;
                this.best = d;
                ctrl.draw(this.bestPath);
                ctrl.logImprove(++this.improvements);
            }                                 
            ctrl.timeout = setTimeout(function() { self.solve(); }, 0);
        };
        this.gasolve = function(){
            ctrl.logIter(this.iteration++);
            var sorted = this.population.getSortedPopulation();
            if(sorted[0].distance < this.best){             
                this.best = sorted[0].distance;
                ctrl.logImprove(++this.improvements);
                ctrl.draw(sorted[0]);
            }
            this.population.crossover(sorted);
            var pl = this.population.genes.length;
            for(var i = 5; i < pl; i++)
                mutate(this.population.genes[i], rand(1));                        
            var self = this;                         
            ctrl.timeout = setTimeout(function() { self.gasolve(); }, 0);
        };
    }; 

    controller.prototype.twoopt = function(ctrl) {

        var path = ctrl.model.randomPath();

        this.solve = function() {

            var model = ctrl.model;
            var pts = model.points;
            var pl = path.length;          
            var running = true;

            for(var i = 0; i < pl && running; i++) {

                var before = i - 1;
                if(i == 0) before = pl - 1;
                var after = i + 1;
                if(i == pl - 1) after = 0;

                for(var j = 0; j < pl && running; j++) {
                    if(j != before && j != i && j != after) {

                        var jAfter = j + 1;
                        if(j == pl - 1) jAfter = 0;

                        var edgeDistance = relativeDist(pts[path[i]], pts[path[after]])
                            + relativeDist(pts[path[j]], pts[path[jAfter]]);

                        var changedDistance = relativeDist(pts[path[i]], pts[path[j]])
                            + relativeDist(pts[path[after]], pts[path[jAfter]]);

                        if(changedDistance < edgeDistance) {

                            var candidate = [];
                            var a = after;
                            while((a % pl) != jAfter) {
                                candidate.push(path[a % pl]);
                                a++;
                            } 
                           
                            a = i;
                            while((a % pl) != j) {
                                candidate.push(path[a % pl]);
                                a--;
                                if(a < 0)
                                    a = pl - 1;
                            }
                            running = false;
                            path = candidate;
                            var self = this;  
                            ctrl.timeout = setTimeout(function() { self.solve(); }, 0); 
                        }                      
                    }
                }
            }

            var d = model.pathDistance(path);
            ctrl.logIter(this.iteration++);
            if(d < this.best){
                this.best = d;
                ctrl.draw(path);
                ctrl.logImprove(this.improvements++);
            }           
        };
    };

    controller.prototype.twooptbest = function(ctrl) {

        var path = ctrl.model.randomPath();

        this.solve = function() {

            var model = ctrl.model;
            var pts = model.points;
            var pl = path.length;           
            var largestDelta = 0;
            var next;

            for(var i = 0; i < pl; i++) {

                var before = i - 1;
                if(i == 0) before = pl - 1;
                var after = i + 1;
                if(i == pl - 1) after = 0;

                for(var j = 0; j < pl; j++) {
                    if(j != before && j != i && j != after) {

                        var jAfter = j + 1;
                        if(j == pl - 1) jAfter = 0;

                        var edgeDistance = relativeDist(pts[path[i]], pts[path[after]])
                            + relativeDist(pts[path[j]], pts[path[jAfter]]);

                        var changedDistance = relativeDist(pts[path[i]], pts[path[j]])
                            + relativeDist(pts[path[after]], pts[path[jAfter]]);

                        var delta = edgeDistance - changedDistance;

                        if(delta > largestDelta) {

                            largestDelta = delta;

                            var candidate = [];
                            var a = after;
                            while((a % pl) != jAfter) {
                                candidate.push(path[a % pl]);
                                a++;
                            } 
                           
                            a = i;
                            while((a % pl) != j) {
                                candidate.push(path[a % pl]);
                                a--;
                                if(a < 0)
                                    a = pl - 1;
                            }                           
                            next = candidate;                           
                        }                      
                    }
                }
            }

            if(largestDelta > 0) {
                path = next;
                var self = this;  
                ctrl.timeout = setTimeout(function() { self.solve(); }, 0); 
            }

            var d = model.pathDistance(path);
            ctrl.logIter(this.iteration++);
            if(d < this.best){
                this.best = d;
                ctrl.draw(path);
                ctrl.logImprove(this.improvements++);
            }           
        };
    };
    
    return {
        Controller:controller
    };
}());

$(document).ready(function(){
    var controller = new TSP.Controller(
        document.getElementById('thecanvas'),
            function(txt){ $('#spnDistance').text(txt); },
            function(txt){ $('#spnIteration').text(txt); },
            function(txt){ $('#spnImprovement').text(txt); }
        );    
    $('#btnGo').click(function(){
        controller.solve($('#ddlAlgo').val());       
    });
    $('#btnStop').click(function(){
        controller.stop();
    }); 
    $('#btnClear').click(function(){       
        controller.clear();
    });    
    $('#btnAddRandom').click(function(){
        controller.addRandom(document.getElementById('txtAddCount').value);
    });     
});
</script>
</head>
<body>
<p>
Click on the canvas to add cities.
</p>
<p>
...or add
<input type="text" id="txtAddCount" value="35" /> random points.
<input type="button" id="btnAddRandom" value="Add" />
</p>
<canvas id="thecanvas" width="800" height="500">
Your browser does not support the canvas element. Sorry.
</canvas>
<div>
<select id="ddlAlgo">   
    <option value="random">One Random Solution</option>   
    <option value="iteraterandom">Iterate Random Solutions</option>   
    <option value="bestnn">Best Nearest Neighbor</option>
    <option value="bruteforce">Brute Force (not recommended for tours > 10)</option>
    <option value="gamutation">Genetic Algorithm - Mutation only</option>
    <option value="gacrossover">Genetic Algorithm - Crossover only</option>
    <option value="ga">Genetic Algorithm - Crossover and Mutation</option>
    <option value="swapimprove">Swap Improvement</option>
    <option value="localpathimprove">Local Path Improvement</option>   
    <option value="bestnnthenga">Best NN, Then GA</option>
    <option value="twoopt">2-opt</option>
    <option value="twooptbest">2-opt: best swap</option>
    <!--
    <option value="bitonic">Optimal Bitonic Tour</option>
    -->
</select>
<input type="button" id="btnGo" value="Solve" />
<input type="button" id="btnStop" value="Stop" />
<input type="button" id="btnClear" value="Clear" />
</div>
<p>
Distance: <span id="spnDistance"></span><br />
Iteration: <span id="spnIteration"></span><br />
Improvements: <span id="spnImprovement"></span>
</p>
</body>
</html>
